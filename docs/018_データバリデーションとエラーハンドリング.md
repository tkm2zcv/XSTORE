# チケット #018: データバリデーションとエラーハンドリング

## 概要
Zod を使用した統一的なデータバリデーションとエラーハンドリングシステムを実装します。
API Routes、フォーム、データベース操作で一貫したバリデーションを提供します。

## 目的
- Zod によるスキーマベースのバリデーション
- API Routes での入力検証
- フロントエンドフォームでのバリデーション
- 統一的なエラーレスポンス形式
- ユーザーフレンドリーなエラーメッセージ

## タスク
- [x] Zod のインストール
  - [x] `npm install zod`
- [x] バリデーションスキーマの作成
  - [x] Account スキーマ
  - [x] PurchaseRequest スキーマ
  - [x] Admin スキーマ
- [x] API バリデーションヘルパーの実装
  - [x] リクエストボディのバリデーション関数
  - [x] クエリパラメータのバリデーション関数
- [x] エラーハンドリングユーティリティの実装
  - [x] 統一的なエラーレスポンス
  - [x] Zod エラーの変換
  - [x] Supabase エラーの変換
- [x] フロントエンドバリデーションの実装
  - [x] React Hook Form との統合
  - [x] Zod Resolver の使用
- [x] カスタムバリデーション関数
  - [x] Twitter ID 形式チェック
  - [x] 日付範囲チェック
  - [x] 価格範囲チェック

## 技術実装

### 1. バリデーションスキーマ

#### `lib/validations.ts`
```typescript
import { z } from 'zod'

// ============================================
// 共通バリデーション
// ============================================

/**
 * Twitter ID バリデーション
 * - @から始まる、または始まらない
 * - 英数字とアンダースコアのみ
 * - 1-15文字
 */
const twitterUsernameSchema = z
  .string()
  .min(1, 'Twitter IDを入力してください')
  .regex(
    /^@?[A-Za-z0-9_]{1,15}$/,
    'Twitter IDは英数字とアンダースコアのみ、1-15文字で入力してください'
  )
  .transform((val) => val.replace(/^@/, '')) // @ を削除

/**
 * メールアドレスバリデーション
 */
const emailSchema = z
  .string()
  .email('正しいメールアドレスを入力してください')

/**
 * URL バリデーション
 */
const urlSchema = z
  .string()
  .url('正しいURLを入力してください')
  .optional()

/**
 * 価格バリデーション
 */
const priceSchema = z
  .number()
  .int('価格は整数で入力してください')
  .min(1, '価格は1円以上で入力してください')
  .max(10000000, '価格は1000万円以下で入力してください')

/**
 * カテゴリバリデーション
 */
const categorySchema = z
  .enum(['ビジネス', 'エンタメ', 'スポーツ', 'ニュース', 'その他'])
  .optional()

// ============================================
// Account スキーマ
// ============================================

/**
 * アカウント作成スキーマ
 */
export const createAccountSchema = z.object({
  username: twitterUsernameSchema,
  display_name: z.string().min(1, '表示名を入力してください').optional(),
  followers_count: z
    .number()
    .int()
    .min(0, 'フォロワー数は0以上で入力してください'),
  following_count: z
    .number()
    .int()
    .min(0, 'フォロー数は0以上で入力してください')
    .optional()
    .default(0),
  tweets_count: z
    .number()
    .int()
    .min(0, 'ツイート数は0以上で入力してください'),
  account_created_date: z
    .string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, '日付はYYYY-MM-DD形式で入力してください')
    .optional(),
  price: priceSchema,
  category: categorySchema,
  description: z.string().max(1000, '説明は1000文字以内で入力してください').optional(),
  image_url: urlSchema,
})

/**
 * アカウント更新スキーマ
 */
export const updateAccountSchema = createAccountSchema
  .partial()
  .extend({
    status: z.enum(['available', 'sold', 'pending']).optional(),
  })

/**
 * アカウント検索スキーマ（クエリパラメータ）
 */
export const accountQuerySchema = z.object({
  category: categorySchema,
  minPrice: z.coerce.number().int().min(0).optional(),
  maxPrice: z.coerce.number().int().max(10000000).optional(),
  minFollowers: z.coerce.number().int().min(0).optional(),
  maxFollowers: z.coerce.number().int().optional(),
  status: z.enum(['available', 'sold', 'pending']).optional().default('available'),
  sortBy: z.enum(['price', 'followers_count', 'created_at']).optional().default('created_at'),
  order: z.enum(['asc', 'desc']).optional().default('desc'),
  page: z.coerce.number().int().min(1).optional().default(1),
  limit: z.coerce.number().int().min(1).max(100).optional().default(12),
})

// ============================================
// PurchaseRequest スキーマ
// ============================================

/**
 * 買取申込作成スキーマ
 */
export const createPurchaseRequestSchema = z
  .object({
    twitter_username: twitterUsernameSchema,
    desired_price: priceSchema,
    contact_email: emailSchema.optional(),
    contact_twitter: twitterUsernameSchema.optional(),
    contact_instagram: z.string().optional(),
    message: z.string().max(1000, 'メッセージは1000文字以内で入力してください').optional(),
    has_image_tweet: z.boolean({
      required_error: '画像ツイートの確認が必要です',
    }),
  })
  .refine(
    (data) => data.contact_email || data.contact_twitter || data.contact_instagram,
    {
      message: '少なくとも1つの連絡先を入力してください',
      path: ['contact_email'],
    }
  )

/**
 * 買取申込ステータス更新スキーマ
 */
export const updatePurchaseRequestSchema = z.object({
  status: z.enum(['pending', 'reviewing', 'approved', 'rejected'], {
    required_error: 'ステータスを選択してください',
  }),
})

/**
 * 買取申込検索スキーマ（クエリパラメータ）
 */
export const purchaseRequestQuerySchema = z.object({
  status: z.enum(['pending', 'reviewing', 'approved', 'rejected']).optional(),
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional(),
  sortBy: z.enum(['created_at', 'desired_price']).optional().default('created_at'),
  order: z.enum(['asc', 'desc']).optional().default('desc'),
  page: z.coerce.number().int().min(1).optional().default(1),
  limit: z.coerce.number().int().min(1).max(100).optional().default(20),
})

// ============================================
// Admin スキーマ
// ============================================

/**
 * ログインスキーマ
 */
export const loginSchema = z.object({
  email: emailSchema,
  password: z.string().min(8, 'パスワードは8文字以上で入力してください'),
})

/**
 * 管理者作成スキーマ
 */
export const createAdminSchema = z.object({
  email: emailSchema,
  password: z
    .string()
    .min(8, 'パスワードは8文字以上で入力してください')
    .regex(
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/,
      'パスワードは英大文字、英小文字、数字を含む必要があります'
    ),
  name: z.string().min(1, '名前を入力してください').optional(),
})

// ============================================
// 型エクスポート
// ============================================

export type CreateAccountInput = z.infer<typeof createAccountSchema>
export type UpdateAccountInput = z.infer<typeof updateAccountSchema>
export type AccountQuery = z.infer<typeof accountQuerySchema>
export type CreatePurchaseRequestInput = z.infer<typeof createPurchaseRequestSchema>
export type UpdatePurchaseRequestInput = z.infer<typeof updatePurchaseRequestSchema>
export type PurchaseRequestQuery = z.infer<typeof purchaseRequestQuerySchema>
export type LoginInput = z.infer<typeof loginSchema>
export type CreateAdminInput = z.infer<typeof createAdminSchema>
```

### 2. API バリデーションヘルパー

#### `lib/api-helpers.ts`
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { z, ZodError } from 'zod'

/**
 * リクエストボディのバリデーション
 */
export async function validateRequestBody<T>(
  request: NextRequest,
  schema: z.ZodSchema<T>
): Promise<{ data: T } | NextResponse> {
  try {
    const body = await request.json()
    const data = schema.parse(body)
    return { data }
  } catch (error) {
    if (error instanceof ZodError) {
      return NextResponse.json(
        {
          error: 'Validation Error',
          details: formatZodError(error),
        },
        { status: 400 }
      )
    }
    return NextResponse.json(
      { error: 'Invalid request body' },
      { status: 400 }
    )
  }
}

/**
 * クエリパラメータのバリデーション
 */
export function validateQueryParams<T>(
  request: NextRequest,
  schema: z.ZodSchema<T>
): { data: T } | NextResponse {
  try {
    const { searchParams } = new URL(request.url)
    const params = Object.fromEntries(searchParams.entries())
    const data = schema.parse(params)
    return { data }
  } catch (error) {
    if (error instanceof ZodError) {
      return NextResponse.json(
        {
          error: 'Validation Error',
          details: formatZodError(error),
        },
        { status: 400 }
      )
    }
    return NextResponse.json(
      { error: 'Invalid query parameters' },
      { status: 400 }
    )
  }
}

/**
 * Zod エラーをフォーマット
 */
function formatZodError(error: ZodError): Record<string, string> {
  const formatted: Record<string, string> = {}
  error.errors.forEach((err) => {
    const path = err.path.join('.')
    formatted[path] = err.message
  })
  return formatted
}
```

### 3. エラーハンドリングユーティリティ

#### `lib/error-handlers.ts`
```typescript
import { NextResponse } from 'next/server'
import { PostgrestError } from '@supabase/supabase-js'

/**
 * エラーレスポンスの型
 */
interface ErrorResponse {
  error: string
  details?: Record<string, string>
  code?: string
}

/**
 * 統一的なエラーレスポンスを作成
 */
export function createErrorResponse(
  message: string,
  status: number,
  details?: Record<string, string>,
  code?: string
): NextResponse<ErrorResponse> {
  return NextResponse.json(
    {
      error: message,
      ...(details && { details }),
      ...(code && { code }),
    },
    { status }
  )
}

/**
 * Supabase エラーをハンドリング
 */
export function handleSupabaseError(error: PostgrestError): NextResponse {
  console.error('Supabase error:', error)

  // 共通エラーコードの処理
  switch (error.code) {
    case '23505': // unique_violation
      return createErrorResponse(
        'このデータは既に存在します',
        409,
        undefined,
        'DUPLICATE_ERROR'
      )
    case '23503': // foreign_key_violation
      return createErrorResponse(
        '関連するデータが見つかりません',
        400,
        undefined,
        'FOREIGN_KEY_ERROR'
      )
    case '23514': // check_violation
      return createErrorResponse(
        '入力データが制約に違反しています',
        400,
        undefined,
        'CHECK_VIOLATION'
      )
    case 'PGRST116': // not found
      return createErrorResponse(
        'データが見つかりません',
        404,
        undefined,
        'NOT_FOUND'
      )
    default:
      return createErrorResponse(
        'データベースエラーが発生しました',
        500,
        undefined,
        error.code
      )
  }
}

/**
 * 汎用エラーハンドラー
 */
export function handleError(error: unknown): NextResponse {
  console.error('Unhandled error:', error)

  if (error instanceof Error) {
    return createErrorResponse(error.message, 500)
  }

  return createErrorResponse('予期しないエラーが発生しました', 500)
}
```

### 4. API Routes での使用例

#### `app/api/accounts/route.ts` を更新
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createServerClient } from '@/lib/supabase'
import { validateRequestBody, validateQueryParams } from '@/lib/api-helpers'
import { handleSupabaseError, handleError } from '@/lib/error-handlers'
import { createAccountSchema, accountQuerySchema } from '@/lib/validations'

export async function GET(request: NextRequest) {
  try {
    // クエリパラメータのバリデーション
    const validationResult = validateQueryParams(request, accountQuerySchema)
    if (validationResult instanceof NextResponse) {
      return validationResult
    }

    const { data: query } = validationResult
    const supabase = createServerClient()

    // クエリ構築
    let queryBuilder = supabase
      .from('accounts')
      .select('*', { count: 'exact' })
      .eq('status', query.status)

    // フィルター適用
    if (query.category) queryBuilder = queryBuilder.eq('category', query.category)
    if (query.minPrice) queryBuilder = queryBuilder.gte('price', query.minPrice)
    if (query.maxPrice) queryBuilder = queryBuilder.lte('price', query.maxPrice)
    if (query.minFollowers) queryBuilder = queryBuilder.gte('followers_count', query.minFollowers)
    if (query.maxFollowers) queryBuilder = queryBuilder.lte('followers_count', query.maxFollowers)

    // ソート適用
    queryBuilder = queryBuilder.order(query.sortBy, { ascending: query.order === 'asc' })

    // ページネーション適用
    const from = (query.page - 1) * query.limit
    const to = from + query.limit - 1
    queryBuilder = queryBuilder.range(from, to)

    const { data, error, count } = await queryBuilder

    if (error) {
      return handleSupabaseError(error)
    }

    return NextResponse.json({
      data,
      pagination: {
        page: query.page,
        limit: query.limit,
        total: count || 0,
        totalPages: Math.ceil((count || 0) / query.limit),
      },
    })
  } catch (error) {
    return handleError(error)
  }
}

export async function POST(request: NextRequest) {
  try {
    // TODO: 認証チェック

    // リクエストボディのバリデーション
    const validationResult = await validateRequestBody(request, createAccountSchema)
    if (validationResult instanceof NextResponse) {
      return validationResult
    }

    const { data: accountData } = validationResult
    const supabase = createServerClient()

    const { data, error } = await supabase
      .from('accounts')
      .insert(accountData)
      .select()
      .single()

    if (error) {
      return handleSupabaseError(error)
    }

    return NextResponse.json({ data }, { status: 201 })
  } catch (error) {
    return handleError(error)
  }
}
```

### 5. フロントエンドバリデーション

#### React Hook Form との統合
```typescript
'use client'

import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { createAccountSchema, CreateAccountInput } from '@/lib/validations'

export function AccountForm() {
  const form = useForm<CreateAccountInput>({
    resolver: zodResolver(createAccountSchema),
    defaultValues: {
      username: '',
      followers_count: 0,
      tweets_count: 0,
      price: 0,
      following_count: 0,
    },
  })

  const onSubmit = async (data: CreateAccountInput) => {
    try {
      const response = await fetch('/api/accounts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      })

      if (!response.ok) {
        const error = await response.json()
        // エラー処理
        console.error(error)
      }
    } catch (error) {
      console.error(error)
    }
  }

  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      {/* フォームフィールド */}
    </form>
  )
}
```

## 依存関係のインストール

```bash
npm install zod react-hook-form @hookform/resolvers
```

## 関連ファイル
- `lib/supabase.ts` - Supabase クライアント
- `types/index.ts` - 型定義
- すべての API Routes

## 依存関係
- チケット #014: アカウント管理 API（バリデーション追加）
- チケット #015: 買取申込管理 API（バリデーション追加）
- チケット #016: 認証システム（ログインバリデーション）

## 完了条件
- [x] Zod がインストールされている
- [x] 全スキーマが定義されている
- [x] API バリデーションヘルパーが実装されている
- [x] エラーハンドリングユーティリティが実装されている
- [x] API Routes にバリデーションが適用されている
- [x] フロントエンドフォームにバリデーションが適用されている
- [x] エラーメッセージがユーザーフレンドリーである

## 備考
- Zod の型推論により TypeScript との統合が容易
- クライアント・サーバー両方で同じスキーマを使用可能
- エラーメッセージは日本語で統一
- 将来的にカスタムバリデーション関数の追加が容易
