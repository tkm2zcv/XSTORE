# チケット #017: 画像アップロード機能

## 概要
Supabase Storage を使用した画像アップロード機能を実装します。
アカウントのプロフィール画像と買取申込の画像ツイート用の2種類のアップロード機能を提供します。

## 目的
- Supabase Storage の設定
- 画像アップロード API の実装
- 画像バリデーション（サイズ・形式）
- 画像最適化（リサイズ・圧縮）
- アップロード UI コンポーネント

## タスク
- [ ] Supabase Storage のバケット作成
  - [ ] `account-images` バケット（プロフィール画像用）
  - [ ] `purchase-images` バケット（買取申込の画像ツイート用）
  - [ ] パブリックアクセス設定
- [ ] 画像アップロード API の実装
  - [ ] `app/api/upload/account-image/route.ts`
  - [ ] `app/api/upload/purchase-image/route.ts`
- [ ] 画像バリデーション機能
  - [ ] ファイルサイズチェック（最大5MB）
  - [ ] ファイル形式チェック（JPEG, PNG, WEBP）
  - [ ] 画像の寸法チェック
- [ ] 画像処理機能
  - [ ] リサイズ（プロフィール画像: 400x400px）
  - [ ] 圧縮（品質80%）
  - [ ] WEBP 変換（オプション）
- [ ] UI コンポーネントの実装
  - [ ] `ImageUpload` コンポーネント
  - [ ] ドラッグ&ドロップ対応
  - [ ] プレビュー機能
  - [ ] アップロード進捗表示
- [ ] エラーハンドリング
  - [ ] ファイルサイズ超過
  - [ ] 不正なファイル形式
  - [ ] アップロード失敗

## 技術実装

### 1. Supabase Storage の設定

#### Storage バケットの作成（Supabase Dashboard）
```sql
-- account-images バケット
-- 設定: Public bucket = true
-- File size limit = 5MB
-- Allowed mime types = image/jpeg, image/png, image/webp

-- purchase-images バケット
-- 設定: Public bucket = true
-- File size limit = 5MB
-- Allowed mime types = image/jpeg, image/png, image/webp
```

#### Storage ポリシーの設定
```sql
-- account-images バケットのポリシー
CREATE POLICY "Anyone can view account images"
ON storage.objects FOR SELECT
USING (bucket_id = 'account-images');

CREATE POLICY "Authenticated users can upload account images"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK (bucket_id = 'account-images');

-- purchase-images バケットのポリシー
CREATE POLICY "Anyone can view purchase images"
ON storage.objects FOR SELECT
USING (bucket_id = 'purchase-images');

CREATE POLICY "Anyone can upload purchase images"
ON storage.objects FOR INSERT
WITH CHECK (bucket_id = 'purchase-images');
```

### 2. 画像アップロード API

#### `app/api/upload/account-image/route.ts`
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { checkAuth } from '@/lib/auth-helpers'
import { createAdminClient } from '@/lib/supabase'
import { validateImage, processImage } from '@/lib/image-utils'

export async function POST(request: NextRequest) {
  try {
    // 認証チェック（管理者のみ）
    const authResult = await checkAuth(request)
    if (authResult instanceof NextResponse) {
      return authResult
    }

    const formData = await request.formData()
    const file = formData.get('file') as File

    if (!file) {
      return NextResponse.json(
        { error: 'No file provided' },
        { status: 400 }
      )
    }

    // バリデーション
    const validation = await validateImage(file, {
      maxSize: 5 * 1024 * 1024, // 5MB
      allowedTypes: ['image/jpeg', 'image/png', 'image/webp'],
    })

    if (!validation.valid) {
      return NextResponse.json(
        { error: validation.error },
        { status: 400 }
      )
    }

    // 画像処理（リサイズ・圧縮）
    const processedImage = await processImage(file, {
      width: 400,
      height: 400,
      quality: 80,
      format: 'webp',
    })

    // Supabase Storage にアップロード
    const supabase = createAdminClient()
    const fileName = `${Date.now()}-${crypto.randomUUID()}.webp`
    const filePath = `accounts/${fileName}`

    const { data, error } = await supabase.storage
      .from('account-images')
      .upload(filePath, processedImage, {
        contentType: 'image/webp',
        cacheControl: '3600',
        upsert: false,
      })

    if (error) {
      return NextResponse.json(
        { error: error.message },
        { status: 500 }
      )
    }

    // 公開URLを取得
    const { data: publicUrlData } = supabase.storage
      .from('account-images')
      .getPublicUrl(filePath)

    return NextResponse.json({
      data: {
        url: publicUrlData.publicUrl,
        path: filePath,
      },
    })
  } catch (error) {
    console.error('Upload error:', error)
    return NextResponse.json(
      { error: 'Internal Server Error' },
      { status: 500 }
    )
  }
}
```

#### `app/api/upload/purchase-image/route.ts`
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createServerClient } from '@/lib/supabase'
import { validateImage, processImage } from '@/lib/image-utils'

export async function POST(request: NextRequest) {
  try {
    // 認証不要（公開フォーム用）

    const formData = await request.formData()
    const file = formData.get('file') as File

    if (!file) {
      return NextResponse.json(
        { error: 'No file provided' },
        { status: 400 }
      )
    }

    // バリデーション
    const validation = await validateImage(file, {
      maxSize: 5 * 1024 * 1024, // 5MB
      allowedTypes: ['image/jpeg', 'image/png', 'image/webp'],
    })

    if (!validation.valid) {
      return NextResponse.json(
        { error: validation.error },
        { status: 400 }
      )
    }

    // 画像処理（リサイズ・圧縮）
    const processedImage = await processImage(file, {
      width: 1200,
      height: 1200,
      quality: 85,
      format: 'webp',
      fit: 'inside', // アスペクト比を維持
    })

    // Supabase Storage にアップロード
    const supabase = createServerClient()
    const fileName = `${Date.now()}-${crypto.randomUUID()}.webp`
    const filePath = `purchases/${fileName}`

    const { data, error } = await supabase.storage
      .from('purchase-images')
      .upload(filePath, processedImage, {
        contentType: 'image/webp',
        cacheControl: '3600',
        upsert: false,
      })

    if (error) {
      return NextResponse.json(
        { error: error.message },
        { status: 500 }
      )
    }

    // 公開URLを取得
    const { data: publicUrlData } = supabase.storage
      .from('purchase-images')
      .getPublicUrl(filePath)

    return NextResponse.json({
      data: {
        url: publicUrlData.publicUrl,
        path: filePath,
      },
    })
  } catch (error) {
    console.error('Upload error:', error)
    return NextResponse.json(
      { error: 'Internal Server Error' },
      { status: 500 }
    )
  }
}
```

### 3. 画像処理ユーティリティ

#### `lib/image-utils.ts`
```typescript
/**
 * 画像バリデーション
 */
interface ValidateImageOptions {
  maxSize: number // バイト単位
  allowedTypes: string[]
  maxWidth?: number
  maxHeight?: number
}

interface ValidationResult {
  valid: boolean
  error?: string
}

export async function validateImage(
  file: File,
  options: ValidateImageOptions
): Promise<ValidationResult> {
  // ファイルサイズチェック
  if (file.size > options.maxSize) {
    return {
      valid: false,
      error: `ファイルサイズが大きすぎます（最大${Math.floor(options.maxSize / 1024 / 1024)}MB）`,
    }
  }

  // ファイル形式チェック
  if (!options.allowedTypes.includes(file.type)) {
    return {
      valid: false,
      error: '対応していないファイル形式です（JPEG, PNG, WEBPのみ）',
    }
  }

  // 画像の寸法チェック（オプション）
  if (options.maxWidth || options.maxHeight) {
    try {
      const dimensions = await getImageDimensions(file)
      if (
        (options.maxWidth && dimensions.width > options.maxWidth) ||
        (options.maxHeight && dimensions.height > options.maxHeight)
      ) {
        return {
          valid: false,
          error: `画像サイズが大きすぎます（最大${options.maxWidth}x${options.maxHeight}px）`,
        }
      }
    } catch (error) {
      return {
        valid: false,
        error: '画像の読み込みに失敗しました',
      }
    }
  }

  return { valid: true }
}

/**
 * 画像の寸法を取得
 */
async function getImageDimensions(
  file: File
): Promise<{ width: number; height: number }> {
  return new Promise((resolve, reject) => {
    const img = new Image()
    img.onload = () => {
      resolve({ width: img.width, height: img.height })
    }
    img.onerror = reject
    img.src = URL.createObjectURL(file)
  })
}

/**
 * 画像処理（リサイズ・圧縮）
 * 注: ブラウザ側で処理する場合は sharp などのライブラリは使用不可
 * サーバー側で処理する場合は sharp を使用できます
 */
interface ProcessImageOptions {
  width: number
  height: number
  quality: number
  format: 'jpeg' | 'png' | 'webp'
  fit?: 'cover' | 'contain' | 'inside'
}

export async function processImage(
  file: File,
  options: ProcessImageOptions
): Promise<Blob> {
  // ブラウザ環境では Canvas API を使用
  // サーバー環境では sharp を使用（npm install sharp）

  // 簡易実装（Canvas API）
  const img = await createImageBitmap(file)
  const canvas = document.createElement('canvas')
  const ctx = canvas.getContext('2d')!

  // リサイズ計算
  let { width, height } = calculateResize(
    img.width,
    img.height,
    options.width,
    options.height,
    options.fit || 'cover'
  )

  canvas.width = width
  canvas.height = height
  ctx.drawImage(img, 0, 0, width, height)

  return new Promise((resolve, reject) => {
    canvas.toBlob(
      (blob) => {
        if (blob) {
          resolve(blob)
        } else {
          reject(new Error('Failed to process image'))
        }
      },
      `image/${options.format}`,
      options.quality / 100
    )
  })
}

function calculateResize(
  originalWidth: number,
  originalHeight: number,
  targetWidth: number,
  targetHeight: number,
  fit: 'cover' | 'contain' | 'inside'
): { width: number; height: number } {
  const aspectRatio = originalWidth / originalHeight

  if (fit === 'inside') {
    // アスペクト比を維持して枠内に収める
    if (originalWidth > targetWidth || originalHeight > targetHeight) {
      if (aspectRatio > targetWidth / targetHeight) {
        return {
          width: targetWidth,
          height: Math.round(targetWidth / aspectRatio),
        }
      } else {
        return {
          width: Math.round(targetHeight * aspectRatio),
          height: targetHeight,
        }
      }
    }
    return { width: originalWidth, height: originalHeight }
  }

  // cover, contain の場合
  if (aspectRatio > targetWidth / targetHeight) {
    return {
      width: fit === 'cover' ? targetWidth : Math.round(targetHeight * aspectRatio),
      height: targetHeight,
    }
  } else {
    return {
      width: targetWidth,
      height: fit === 'cover' ? targetHeight : Math.round(targetWidth / aspectRatio),
    }
  }
}
```

### 4. ImageUpload コンポーネント

#### `components/forms/ImageUpload.tsx`
```typescript
'use client'

import { useState, useRef } from 'react'
import { Upload, X } from 'lucide-react'
import { Button } from '@/components/ui/button'
import Image from 'next/image'

interface ImageUploadProps {
  value?: string
  onChange: (url: string) => void
  endpoint: '/api/upload/account-image' | '/api/upload/purchase-image'
  maxSize?: number // MB
}

export function ImageUpload({
  value,
  onChange,
  endpoint,
  maxSize = 5,
}: ImageUploadProps) {
  const [uploading, setUploading] = useState(false)
  const [preview, setPreview] = useState<string | null>(value || null)
  const [error, setError] = useState<string | null>(null)
  const fileInputRef = useRef<HTMLInputElement>(null)

  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (!file) return

    setError(null)

    // ファイルサイズチェック
    if (file.size > maxSize * 1024 * 1024) {
      setError(`ファイルサイズが大きすぎます（最大${maxSize}MB）`)
      return
    }

    // プレビュー表示
    const reader = new FileReader()
    reader.onloadend = () => {
      setPreview(reader.result as string)
    }
    reader.readAsDataURL(file)

    // アップロード
    setUploading(true)
    try {
      const formData = new FormData()
      formData.append('file', file)

      const response = await fetch(endpoint, {
        method: 'POST',
        body: formData,
      })

      if (!response.ok) {
        const error = await response.json()
        throw new Error(error.error || 'Upload failed')
      }

      const { data } = await response.json()
      onChange(data.url)
    } catch (error) {
      console.error('Upload error:', error)
      setError(error instanceof Error ? error.message : 'アップロードに失敗しました')
      setPreview(null)
    } finally {
      setUploading(false)
    }
  }

  const handleRemove = () => {
    setPreview(null)
    onChange('')
    if (fileInputRef.current) {
      fileInputRef.current.value = ''
    }
  }

  return (
    <div className="space-y-4">
      {preview ? (
        <div className="relative w-full aspect-square max-w-sm rounded-lg overflow-hidden">
          <Image
            src={preview}
            alt="Preview"
            fill
            className="object-cover"
          />
          <Button
            type="button"
            variant="destructive"
            size="icon"
            className="absolute top-2 right-2"
            onClick={handleRemove}
          >
            <X className="h-4 w-4" />
          </Button>
        </div>
      ) : (
        <div
          className="border-2 border-dashed border-muted-foreground/25 rounded-lg p-8 text-center cursor-pointer hover:border-muted-foreground/50 transition"
          onClick={() => fileInputRef.current?.click()}
        >
          <Upload className="h-10 w-10 mx-auto mb-4 text-muted-foreground" />
          <p className="text-sm text-muted-foreground">
            クリックして画像を選択
          </p>
          <p className="text-xs text-muted-foreground mt-2">
            JPEG, PNG, WEBP（最大{maxSize}MB）
          </p>
        </div>
      )}

      <input
        ref={fileInputRef}
        type="file"
        accept="image/jpeg,image/png,image/webp"
        onChange={handleFileChange}
        className="hidden"
        disabled={uploading}
      />

      {error && <p className="text-sm text-red-500">{error}</p>}
      {uploading && <p className="text-sm text-muted-foreground">アップロード中...</p>}
    </div>
  )
}
```

## 環境変数

特に追加の環境変数は不要です。Supabase の既存の設定を使用します。

## 使用例

### 管理画面でのアカウント画像アップロード
```typescript
'use client'

import { ImageUpload } from '@/components/forms/ImageUpload'

export function AccountForm() {
  const [imageUrl, setImageUrl] = useState('')

  return (
    <form>
      <ImageUpload
        value={imageUrl}
        onChange={setImageUrl}
        endpoint="/api/upload/account-image"
        maxSize={5}
      />
    </form>
  )
}
```

### 買取申込フォームでの画像アップロード
```typescript
'use client'

import { ImageUpload } from '@/components/forms/ImageUpload'

export function PurchaseForm() {
  const [imageUrl, setImageUrl] = useState('')

  return (
    <form>
      <ImageUpload
        value={imageUrl}
        onChange={setImageUrl}
        endpoint="/api/upload/purchase-image"
        maxSize={5}
      />
    </form>
  )
}
```

## セキュリティ考慮事項

### ファイルサイズ制限
- クライアント側: 5MB
- サーバー側: 5MB
- Supabase Storage: 5MB

### ファイル形式制限
- JPEG, PNG, WEBP のみ許可
- MIME type チェック
- 拡張子チェック

### アクセス制御
- アカウント画像: 認証済みユーザー（管理者）のみアップロード可能
- 買取申込画像: 誰でもアップロード可能（公開フォーム用）
- 読み取りは全て公開

### レート制限
- 将来的に実装を検討（1日あたりのアップロード回数制限）

## 関連ファイル
- `lib/supabase.ts` - Supabase クライアント
- `components/ui/*` - UI コンポーネント

## 依存関係
- チケット #002: データベース設計（完了）
- チケット #014: アカウント管理 API（image_url フィールド使用）
- チケット #015: 買取申込管理 API（tweet_image_url フィールド使用）
- チケット #016: 認証システム（アカウント画像アップロードで必要）

## 完了条件
- [ ] Supabase Storage のバケットが作成されている
- [ ] 画像アップロード API が正常に動作する
- [ ] 画像バリデーションが正常に動作する
- [ ] 画像処理（リサイズ・圧縮）が正常に動作する
- [ ] ImageUpload コンポーネントが正常に動作する
- [ ] プレビュー機能が正常に動作する
- [ ] エラーハンドリングが適切に実装されている

## 備考
- 画像処理は `sharp` ライブラリの使用を推奨（サーバーサイド）
- ブラウザ側で処理する場合は Canvas API を使用
- WEBP 形式への変換で容量削減
- 古い画像の削除機能は将来の拡張として別チケットで実装
