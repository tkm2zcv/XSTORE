# チケット #014: API Routes - アカウント管理API

## 概要
販売中アカウントの CRUD 操作を行う API Routes を実装します。
公開ページでの閲覧、管理画面での作成・更新・削除機能を提供します。

## 目的
- アカウント一覧の取得（フィルター・ソート対応）
- アカウント詳細の取得
- アカウントの作成（管理者のみ）
- アカウントの更新（管理者のみ）
- アカウントの削除（管理者のみ）

## タスク
- [x] `app/api/accounts/route.ts` を作成
  - [x] GET: アカウント一覧取得（クエリパラメータでフィルター・ソート）
  - [x] POST: アカウント作成（認証チェック）
- [x] `app/api/accounts/[id]/route.ts` を作成
  - [x] GET: 特定アカウントの詳細取得
  - [x] PUT: アカウント更新（認証チェック）
  - [x] DELETE: アカウント削除（認証チェック）
- [x] クエリパラメータ処理の実装
  - [x] フィルター: `category`, `minPrice`, `maxPrice`, `minFollowers`, `maxFollowers`, `status`
  - [x] ソート: `price`, `followers_count`, `created_at`
  - [x] ページネーション: `page`, `limit`
- [x] エラーハンドリングの実装
  - [x] 404: アカウントが見つからない
  - [x] 401: 認証エラー
  - [x] 400: バリデーションエラー
  - [x] 500: サーバーエラー
- [x] レスポンス形式の統一
  - [x] 成功時: `{ data: T }`
  - [x] エラー時: `{ error: string }`

## 技術実装

### エンドポイント仕様

#### GET `/api/accounts`
```typescript
// クエリパラメータ
interface AccountsQuery {
  category?: string
  minPrice?: number
  maxPrice?: number
  minFollowers?: number
  maxFollowers?: number
  status?: 'available' | 'sold' | 'pending'
  sortBy?: 'price' | 'followers_count' | 'created_at'
  order?: 'asc' | 'desc'
  page?: number
  limit?: number
}

// レスポンス
interface AccountsResponse {
  data: Account[]
  pagination: {
    page: number
    limit: number
    total: number
    totalPages: number
  }
}
```

#### GET `/api/accounts/[id]`
```typescript
// レスポンス
interface AccountResponse {
  data: Account
}
```

#### POST `/api/accounts`
```typescript
// リクエストボディ
interface CreateAccountRequest {
  username: string
  display_name?: string
  followers_count: number
  following_count: number
  tweets_count: number
  account_created_date?: string
  price: number
  category?: string
  description?: string
  image_url?: string
}

// レスポンス
interface CreateAccountResponse {
  data: Account
}
```

#### PUT `/api/accounts/[id]`
```typescript
// リクエストボディ
interface UpdateAccountRequest {
  username?: string
  display_name?: string
  followers_count?: number
  following_count?: number
  tweets_count?: number
  account_created_date?: string
  price?: number
  category?: string
  description?: string
  status?: 'available' | 'sold' | 'pending'
  image_url?: string
}

// レスポンス
interface UpdateAccountResponse {
  data: Account
}
```

#### DELETE `/api/accounts/[id]`
```typescript
// レスポンス
interface DeleteAccountResponse {
  data: { id: string }
}
```

## 実装例

### `app/api/accounts/route.ts`
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createServerClient } from '@/lib/supabase'

export async function GET(request: NextRequest) {
  try {
    const supabase = createServerClient()
    const { searchParams } = new URL(request.url)

    // クエリパラメータの取得
    const category = searchParams.get('category')
    const minPrice = searchParams.get('minPrice')
    const maxPrice = searchParams.get('maxPrice')
    const minFollowers = searchParams.get('minFollowers')
    const maxFollowers = searchParams.get('maxFollowers')
    const status = searchParams.get('status') || 'available'
    const sortBy = searchParams.get('sortBy') || 'created_at'
    const order = searchParams.get('order') || 'desc'
    const page = parseInt(searchParams.get('page') || '1')
    const limit = parseInt(searchParams.get('limit') || '12')

    // クエリ構築
    let query = supabase
      .from('accounts')
      .select('*', { count: 'exact' })
      .eq('status', status)

    // フィルター適用
    if (category) query = query.eq('category', category)
    if (minPrice) query = query.gte('price', parseInt(minPrice))
    if (maxPrice) query = query.lte('price', parseInt(maxPrice))
    if (minFollowers) query = query.gte('followers_count', parseInt(minFollowers))
    if (maxFollowers) query = query.lte('followers_count', parseInt(maxFollowers))

    // ソート適用
    query = query.order(sortBy, { ascending: order === 'asc' })

    // ページネーション適用
    const from = (page - 1) * limit
    const to = from + limit - 1
    query = query.range(from, to)

    const { data, error, count } = await query

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 })
    }

    return NextResponse.json({
      data,
      pagination: {
        page,
        limit,
        total: count || 0,
        totalPages: Math.ceil((count || 0) / limit),
      },
    })
  } catch (error) {
    return NextResponse.json(
      { error: 'Internal Server Error' },
      { status: 500 }
    )
  }
}

export async function POST(request: NextRequest) {
  try {
    // TODO: 認証チェック（チケット #016 で実装）
    // const session = await getServerSession()
    // if (!session) {
    //   return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    // }

    const supabase = createServerClient()
    const body = await request.json()

    // TODO: バリデーション（チケット #018 で実装）

    const { data, error } = await supabase
      .from('accounts')
      .insert(body)
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 400 })
    }

    return NextResponse.json({ data }, { status: 201 })
  } catch (error) {
    return NextResponse.json(
      { error: 'Internal Server Error' },
      { status: 500 }
    )
  }
}
```

### `app/api/accounts/[id]/route.ts`
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createServerClient } from '@/lib/supabase'

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const supabase = createServerClient()
    const { data, error } = await supabase
      .from('accounts')
      .select('*')
      .eq('id', params.id)
      .single()

    if (error) {
      return NextResponse.json({ error: 'Account not found' }, { status: 404 })
    }

    return NextResponse.json({ data })
  } catch (error) {
    return NextResponse.json(
      { error: 'Internal Server Error' },
      { status: 500 }
    )
  }
}

export async function PUT(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // TODO: 認証チェック（チケット #016 で実装）

    const supabase = createServerClient()
    const body = await request.json()

    // TODO: バリデーション（チケット #018 で実装）

    const { data, error } = await supabase
      .from('accounts')
      .update(body)
      .eq('id', params.id)
      .select()
      .single()

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 400 })
    }

    return NextResponse.json({ data })
  } catch (error) {
    return NextResponse.json(
      { error: 'Internal Server Error' },
      { status: 500 }
    )
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // TODO: 認証チェック（チケット #016 で実装）

    const supabase = createServerClient()
    const { error } = await supabase
      .from('accounts')
      .delete()
      .eq('id', params.id)

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 400 })
    }

    return NextResponse.json({ data: { id: params.id } })
  } catch (error) {
    return NextResponse.json(
      { error: 'Internal Server Error' },
      { status: 500 }
    )
  }
}
```

## 関連ファイル
- `lib/supabase.ts` - Supabase クライアント
- `types/index.ts` - Account 型定義
- `supabase/schema.sql` - accounts テーブル定義

## 依存関係
- チケット #002: データベース設計（完了）
- チケット #016: 認証ミドルウェア（POST/PUT/DELETE で必要）
- チケット #018: バリデーション（全エンドポイントで必要）

## 完了条件
- [x] 全エンドポイントが正常に動作する
- [x] フィルター・ソート機能が正しく動作する
- [x] ページネーションが正しく動作する
- [x] エラーハンドリングが適切に実装されている
- [x] レスポンス形式が統一されている

## 備考
- RLS ポリシーにより、公開ページでは `status='available'` のアカウントのみ取得可能
- 認証済みユーザー（管理者）は全アカウントを取得可能
- 画像アップロードは別チケット (#017) で実装
